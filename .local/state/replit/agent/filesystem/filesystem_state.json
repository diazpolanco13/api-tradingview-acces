{"file_contents":{"README.md":{"content":"# 🚀 TradingView API Management v2\n**Advanced RESTful API System for Pine Script Access Management with Secure Admin Panel**\n\n[![Replit](https://img.shields.io/badge/Deploy%20on-Replit-blue?logo=replit)](https://replit.com/@trendoscope/Tradingview-Access-Management)\n[![GitHub](https://img.shields.io/badge/GitHub-Repository-black?logo=github)](https://github.com/diazpolanco13/TradingView-API-Management-v2)\n\n> **⚡ Complete automation solution for TradingView Pine Script access management with secure authentication, real-time validation, and professional admin interface.**\n\n---\n\n## 🌟 **What's New in v2**\n\n### 🎯 **Major Enhancements**\n- ✅ **Secure Web Admin Panel** - Professional interface with token-based authentication\n- ✅ **Real-time Cookie Management** - Automatic validation and manual update system  \n- ✅ **Individual Endpoint Testing** - Six dedicated test buttons for each API function\n- ✅ **Enhanced Security** - Header-based admin token authentication (never in URLs)\n- ✅ **Bug Fixes** - Corrected 30-day access period (now properly uses `1M` format)\n- ✅ **Profile Integration** - Automatic display of username, balance, and profile image\n- ✅ **Live Status Monitoring** - Real-time verification of TradingView session status\n\n### 🔧 **Technical Improvements**\n- **Manual Cookie Extraction**: Bypasses bot detection and reCAPTCHA\n- **Database Session Storage**: Persistent cookie management via Replit database\n- **Token Auto-generation**: Cryptographically secure admin tokens\n- **Enhanced Error Handling**: Comprehensive validation and user feedback\n- **Professional UI/UX**: Bootstrap-based responsive admin interface\n\n---\n\n## 🏗️ **System Architecture**\n\n### **Backend Components**\n- **Flask API Server** (`src/server.py`) - RESTful endpoints with authentication\n- **TradingView Integration** (`src/tradingview.py`) - Session and API management\n- **Helper Functions** (`src/helper.py`) - Date calculations and utilities\n- **Configuration** (`config.py`) - Centralized URL management\n\n### **Frontend Components**  \n- **Admin Panel** (`templates/admin.html`) - Professional web interface\n- **Login System** - Secure token-based authentication\n- **Testing Interface** - Individual endpoint validation tools\n\n### **Security Layer**\n- **Token Authentication**: Auto-generated secure admin tokens\n- **Session Validation**: Real-time cookie status verification\n- **Header-based Auth**: X-Admin-Token headers (never query parameters)\n- **Database Encryption**: Secure session storage\n\n---\n\n## 🚀 **Quick Setup**\n\n### **1. Deploy on Replit**\n```bash\n# Clone the repository\ngit clone https://github.com/diazpolanco13/TradingView-API-Management-v2.git\n\n# Or use Replit import from GitHub\n```\n\n### **2. Environment Configuration**\nSet up these environment variables in Replit Secrets:\n```env\nusername=your_tradingview_username\npassword=your_tradingview_password\n```\n> **⚠️ Requirements**: Premium TradingView subscription needed for API access.\n\n### **3. Run the Application**\n```bash\npython main.py\n```\n\n**🔐 Admin Token**: The system auto-generates a secure token displayed in console:\n```\n🔐 Admin token generado para esta sesión:\n   tvapi-abc123def456...\n   Usa este token para acceder al panel de administración\n```\n\n---\n\n## 🎮 **Admin Panel Usage**\n\n### **Accessing the Panel**\n1. **Navigate to**: `https://your-repl-name.replit.app/`\n2. **Enter Admin Token**: Use the generated token from console\n3. **Dashboard Access**: Full system control and testing\n\n### **Cookie Management**\n- **Automatic Validation**: System checks cookie status on load from JSON file\n- **Manual Updates**: Easy cookie refresh when sessions expire (saves to JSON)\n- **Real-time Status**: Live indicator of authentication state\n- **Persistent Storage**: Cookies survive application restarts via local JSON files\n- **Migration Note**: When upgrading from v1, cookies need to be re-entered once via admin panel\n\n### **Endpoint Testing**\nSix individual test buttons for complete API validation:\n1. **🔍 Validate User** - Check username existence\n2. **👀 Check Access** - Verify current user permissions  \n3. **✅ Grant 30 Days** - Add month-long access\n4. **🔄 Verify Grant** - Confirm access was granted\n5. **❌ Revoke Access** - Remove user permissions\n6. **✔️ Verify Revoke** - Confirm access removal\n\n---\n\n## 📡 **API Endpoints**\n\n### **Public Endpoints**\n\n#### **`GET /validate/{username}`**\nValidates TradingView username existence.\n\n**Response:**\n```json\n{\n    \"valid\": true,\n    \"verified_username\": \"ExactUsername\"\n}\n```\n\n---\n\n### **Protected Endpoints** \n> **🔐 Authentication Required**: All admin endpoints require `X-Admin-Token` header\n\n#### **`GET /access/{username}?indicator_id={pine_id}`**\nCheck user's current access status for specific indicator.\n\n**Headers:**\n```\nX-Admin-Token: tvapi-your-admin-token\n```\n\n**Response:**\n```json\n{\n    \"has_access\": true,\n    \"indicator_id\": \"PUB;abc123...\",\n    \"username\": \"user123\",\n    \"expiration\": \"2025-10-27T19:28:29.087215+00:00\",\n    \"no_expiration\": false,\n    \"status\": \"checked\"\n}\n```\n\n#### **`POST /access/{username}`**\nGrant access to user for specified duration.\n\n**Headers:**\n```\nX-Admin-Token: tvapi-your-admin-token\nContent-Type: application/json\n```\n\n**Payload:**\n```json\n{\n    \"indicator_id\": \"PUB;abc123...\",\n    \"days\": 30\n}\n```\n\n**Duration Formats:**\n- **30 days**: `\"days\": 30` → Automatically converts to `1M` (1 month)\n- **Other periods**: Direct day values\n- **Lifetime**: Use appropriate endpoint\n\n**Response:**\n```json\n{\n    \"success\": true,\n    \"message\": \"Access granted for 30 days\"\n}\n```\n\n#### **`DELETE /access/{username}?indicator_id={pine_id}`**\nRevoke user access from indicator.\n\n**Headers:**\n```\nX-Admin-Token: tvapi-your-admin-token\n```\n\n**Response:**\n```json\n{\n    \"success\": true,\n    \"message\": \"Access revoked successfully\"\n}\n```\n\n---\n\n## 🔒 **Security Features**\n\n### **Authentication System**\n- **Auto-generated Tokens**: Cryptographically secure random tokens\n- **Session-based**: New token per application restart\n- **Header Authentication**: Never exposed in URLs or query parameters\n\n### **Cookie Management & Data Persistence**\n- **Manual Extraction**: Bypasses TradingView's bot detection\n- **JSON File Storage**: Local persistent session management via `data/cookies.json`\n- **File Permissions**: Restricted to owner-only (600) for security\n- **Automatic Validation**: Real-time authentication status verification\n- **Docker Compatible**: Configurable storage path via `COOKIE_FILE` environment variable\n- **Session Recovery**: Cookies persist across application restarts until manually renewed\n\n### **API Security**\n- **Protected Endpoints**: All admin operations require authentication\n- **Input Validation**: Comprehensive payload verification\n- **Error Handling**: No sensitive information exposure\n\n---\n\n## 🔧 **Technical Details**\n\n### **TradingView Integration**\nThe system uses TradingView's internal API endpoints:\n- **Username validation**: `/pine_perm/username_hint/`\n- **Access management**: `/pine_perm/modify_access/` and `/pine_perm/add_access/`\n- **User verification**: `/u/{username}/` profile pages\n- **Account data**: `/accounts/balance/` for user information\n\n### **Date Period Handling**\n**Critical Fix**: 30-day access periods now properly use `1M` format:\n```python\n# ✅ Correct implementation\nif days == 30:\n    tv.add_access(access, 'M', 1)  # 1 month = ~30 days\nelse:\n    tv.add_access(access, 'd', days)  # Direct day values\n```\n\n### **Data Persistence (JSON Storage)**\n**Local file-based storage** for Docker compatibility:\n```json\n// data/cookies.json\n{\n  \"tv_sessionid\": \"session_cookie_value\",\n  \"tv_sessionid_sign\": \"signature_cookie_value\", \n  \"cookies_updated_at\": \"2025-09-27T21:39:26.000000\"\n}\n```\n\n**Storage Management**:\n```python\n# Cookie Manager handles all persistence\ncookie_manager = CookieManager()\ncookie_manager.save_cookies(sessionid, sessionid_sign)  # Saves to JSON\nsessionid, sessionid_sign, timestamp = cookie_manager.load_cookies()  # Loads from JSON\n```\n\n**File Security**:\n- **Location**: `data/cookies.json` (configurable via `COOKIE_FILE` env var)\n- **Permissions**: Automatically set to 600 (owner read/write only)\n- **Gitignored**: Excluded from version control for security\n- **Docker Volumes**: Mount `data/` directory for persistent storage\n\n---\n\n## 🎯 **Use Cases**\n\n### **For Script Vendors**\n- **Automated Access Management**: Grant/revoke access programmatically\n- **Subscription Handling**: Integrate with payment systems\n- **User Validation**: Verify customers before processing\n- **Bulk Operations**: Manage multiple users efficiently\n\n### **For Developers**\n- **API Integration**: RESTful endpoints for external systems\n- **Webhook Support**: Easy integration with payment processors\n- **Admin Interface**: Non-technical user management\n- **Testing Tools**: Validate functionality before deployment\n\n---\n\n## 🛠️ **Development**\n\n### **Project Structure**\n```\n├── src/\n│   ├── server.py          # Flask API server\n│   ├── tradingview.py     # TradingView integration\n│   └── helper.py          # Utility functions\n├── templates/\n│   └── admin.html         # Admin panel interface\n├── config.py              # Configuration management\n├── main.py                # Application entry point\n└── replit.md              # Project documentation\n```\n\n### **Dependencies**\n- **Flask**: Web framework and API server\n- **requests**: HTTP client for TradingView API\n- **python-dateutil**: Advanced date calculations\n- **Replit Database**: Built-in key-value storage\n\n---\n\n## 🔍 **Troubleshooting**\n\n### **Common Issues**\n\n#### **Cookie Expiration**\n**Symptoms**: API returns authentication errors, \"No valid cookies found\" in logs\n**Solution**: \n1. Open admin panel at `https://your-app.com/`\n2. Click \"Update Cookies\" button  \n3. Follow manual extraction instructions\n4. Cookies automatically save to `data/cookies.json`\n\n#### **Token Authentication**\n**Symptoms**: \"Unauthorized\" responses\n**Solution**: \n1. Check console for current admin token (development mode shows full token)\n2. Include token in `X-Admin-Token` header\n3. Restart application for new token if needed\n\n#### **30-Day Access Issues**\n**Fixed**: System now properly uses `1M` (1 month) format instead of `30D`\n\n#### **Data Persistence Issues**\n**Symptoms**: Cookies lost after restart, need to re-authenticate frequently\n**Solution**:\n1. **Development**: Cookies auto-save to `data/cookies.json` in project directory\n2. **Docker**: Mount `data/` as persistent volume: `docker run -v cookies_data:/app/data your_image`\n3. **Custom Path**: Set `COOKIE_FILE=/custom/path/cookies.json` environment variable\n\n---\n\n## 📈 **Monitoring**\n\n### **Built-in Diagnostics**\n- **Cookie Status**: Real-time session validation\n- **API Health**: Endpoint response monitoring\n- **User Balance**: Account information display\n- **Error Logging**: Comprehensive debugging information\n\n### **Admin Dashboard**\n- **Profile Information**: Username, balance, profile image\n- **System Status**: Real-time operational indicators\n- **Test Results**: Individual endpoint validation\n- **Session Management**: Cookie status and refresh options\n\n---\n\n## 🚀 **Publishing**\n\nDeploy your API to production with Replit's built-in deployment:\n1. **Test thoroughly** using the admin panel\n2. **Configure environment** variables properly\n3. **Deploy** via Replit's \"Publish\" button\n4. **Custom domain** available with Replit Pro\n\n---\n\n## 🤝 **Contributing**\n\n### **Development Setup**\n1. Fork the repository\n2. Create feature branch\n3. Test with admin panel\n4. Submit pull request\n\n### **Bug Reports**\nUse the admin panel's testing interface to validate issues before reporting.\n\n---\n\n## 📞 **Support & Links**\n\n### **Referral Programs**\nIf you found this project useful, consider using these referral links:\n- **[TradingView Premium](https://www.tradingview.com/?aff_id=112733)** \n- **[Bybit Trading](https://partner.bybit.com/b/TRENDOSCOPE)**\n- **[BingX Exchange](https://bingx.com/en-us/partner/Trendoscope/)**\n\n### **Original Developer**\n<div align=\"center\">\n<a href=\"https://p.trendoscope.au/\"><img src=\"https://s3.tradingview.com/userpics/7387160-gqgs_big.png\" width=\"100\" height=\"100\"></a>\n<a href=\"https://p.trendoscope.au/twitter\"><img src=\"https://i.pinimg.com/originals/aa/3d/75/aa3d750ddec109594ac7c89cb8cbabab.jpg\" width=\"100\" height=\"100\"></a>\n<a href=\"https://p.trendoscope.au/telegram\"><img src=\"https://i.pinimg.com/originals/70/c3/ea/70c3ea9e43ebd11ec98de96937529408.jpg\" width=\"100\" height=\"100\"></a>\n<a href=\"https://p.trendoscope.au/discord\"><img src=\"https://i.pinimg.com/originals/b6/fe/4a/b6fe4a830e0263d8344b63e3dbcf3033.jpg\" width=\"100\" height=\"100\"></a>\n<a href=\"https://p.trendoscope.au/youtube\"><img src=\"https://i.pinimg.com/originals/f4/14/b8/f414b816ef11df2c1eaae61f2fc8c489.jpg\" width=\"100\" height=\"100\"></a>\n</div>\n\n---\n\n## 📄 **License**\n\nThis project is provided as-is for educational and commercial use. Please ensure compliance with TradingView's Terms of Service when using their APIs.\n\n---\n\n<div align=\"center\">\n\n**🎯 Ready to automate your TradingView Pine Script access management?**\n\n[🚀 **Deploy Now**](https://replit.com/@trendoscope/Tradingview-Access-Management) • [📚 **Documentation**](https://github.com/diazpolanco13/TradingView-API-Management-v2) • [💬 **Support**](https://p.trendoscope.au/discord)\n\n</div>","size_bytes":13498},"main.py":{"content":"import src.server as server\nimport os\n\nif __name__ == '__main__':\n    # Set admin token if not already set\n    if not os.getenv('ADMIN_TOKEN'):\n        # For production, require ADMIN_TOKEN to be set via environment\n        # For development, generate a secure token for this session\n        import secrets\n        admin_token = f\"tvapi-{secrets.token_urlsafe(32)}\"\n        os.environ['ADMIN_TOKEN'] = admin_token\n        print(\"🔐 Admin token generado para esta sesión:\")\n        \n        # Solo mostrar el token completo en desarrollo (no en producción/Docker)\n        if os.getenv('ENV') == 'production':\n            print(\"   Token: [HIDDEN - available in environment variables]\")\n            print(\"   ⚠️  Para seguridad en producción, el token no se muestra en logs\")\n        else:\n            print(f\"   {admin_token}\")\n            print(\"   ⚠️  Token completo mostrado arriba\")\n            print(\"   Para producción, configure ADMIN_TOKEN en variables de entorno\")\n    else:\n        print(\"✅ Admin panel secured with configured token\")\n    \n    server.start_server()","size_bytes":1090},"pyproject.toml":{"content":"[tool.poetry]\nname = \"python-template\"\nversion = \"0.1.0\"\ndescription = \"\"\nauthors = [\"Your Name <you@example.com>\"]\n\n[tool.poetry.dependencies]\npython = \"^3.10\"\nFlask = \"^2.2.0\"\nrequests = \"^2.28.1\"\nurllib3 = \"^1.26.11\"\npython-dateutil = \"^2.8.2\"\n\n[tool.poetry.dev-dependencies]\ndebugpy = \"^1.6.2\"\npython-lsp-server = {extras = [\"yapf\", \"rope\", \"pyflakes\"], version = \"^1.5.0\"}\ntoml = \"^0.10.2\"\n\n[build-system]\nrequires = [\"poetry-core>=1.0.0\"]\nbuild-backend = \"poetry.core.masonry.api\"","size_bytes":486},"replit.md":{"content":"# Overview\n\nThis project is a RESTful API service for managing TradingView script access management. It's designed for vendors to manage user access to their TradingView publications programmatically. The API provides endpoints for username validation, checking current access levels, and modifying user permissions for TradingView Pine scripts.\n\nThe service requires a Premium TradingView subscription to function properly and is intended to be deployed on Replit with appropriate security measures.\n\n# User Preferences\n\nPreferred communication style: Simple, everyday language.\n\n# System Architecture\n\n## Backend Framework\n- **Flask**: Lightweight web framework providing RESTful API endpoints\n- **Python**: Core language for all backend logic and TradingView integration\n\n## Authentication & Security\n- **Admin Token Authentication**: Secure admin panel access using environment-based token authentication\n- **Session Management**: TradingView session cookie management stored in Replit database\n- **Header-based Security**: Admin operations require X-Admin-Token header (never query parameters)\n\n## Data Storage\n- **Replit Database**: Simple key-value store for persisting TradingView session cookies\n- **Environment Variables**: Configuration storage for credentials and admin tokens\n\n## External Integration\n- **TradingView API**: Custom integration with TradingView's internal endpoints for:\n  - Username validation (`username_hint`)\n  - User access management (`pine_perm` endpoints)\n  - Account balance checking (`tvcoins`)\n  - Session authentication (`accounts/signin`)\n\n## Core Components\n\n### Session Management (`tradingview.py`)\nHandles TradingView authentication by managing session cookies stored in the database. Automatically validates stored cookies and provides fallback error handling when manual cookie updates are required.\n\n### API Endpoints (`server.py`)\n- **Public Endpoint**: `/validate/<username>` - Username validation without authentication\n- **Protected Endpoints**: All access management operations require admin token\n- **Admin Panel**: Web interface for cookie management and system administration\n\n### Configuration (`config.py`)\nCentralized URL configuration for all TradingView API endpoints, making the system maintainable and allowing for easy endpoint updates.\n\n### Helper Functions (`helper.py`)\nDate manipulation utilities for extending user access periods using relativedelta for accurate calendar arithmetic.\n\n## Deployment Architecture\n- **Replit Platform**: Cloud hosting with built-in database and environment management\n- **Auto-scaling**: Replit handles server scaling and availability\n- **Environment Configuration**: Simple setup requiring only TradingView credentials\n\n## Security Considerations\n- Admin token generation with secure random values\n- Session cookie validation and automatic refresh detection\n- Protected admin endpoints with proper authentication headers\n- Error handling that doesn't expose sensitive information\n\n# Recent Updates\n\n## September 28, 2025 - Web Navigation System Implemented\n- **Session-Based Authentication**: Implemented Flask session authentication alongside existing token system\n- **Web Routes**: Added navigable routes (/dashboard, /clients, /indicators, /access) with automatic login protection\n- **Unified Authentication**: APIs now accept both session cookies and token headers for maximum flexibility\n- **Complete Templates**: Full HTML interfaces for all administrative functions with responsive design\n- **Seamless Navigation**: After login, users can navigate directly between sections without re-authentication\n- **Security Improvements**: Protected routes automatically redirect to login with return URLs\n- **Production Ready**: All authentication flows tested and verified working\n\n## September 28, 2025 - Replit Environment Setup Completed\n- **Production Ready**: Successfully imported from GitHub and configured for Replit environment\n- **Poetry Dependencies**: All Python packages installed via Poetry (Flask, requests, urllib3, python-dateutil)\n- **Flask Server**: Properly configured for Replit proxy with 0.0.0.0:5000 binding\n- **Admin Panel**: Fully functional web interface with token authentication\n- **API Endpoints**: All REST endpoints tested and working (/validate/, /access/)\n- **Deployment Configuration**: VM deployment configured for production\n- **Data Directory**: Created for cookie storage with proper file permissions\n- **Workflow Configuration**: Optimized Poetry-based Flask server startup\n\n## December 27, 2025 - Panel de Administración Implementado\n- **Panel Web Seguro**: Interfaz web completa para gestionar cookies de TradingView con autenticación por token\n- **Información de Perfil**: Sistema obtiene automáticamente imagen de perfil, username, balance y estado de partner\n- **Seguridad Robusta**: Autenticación por token X-Admin-Token con generación automática de tokens seguros\n- **Detección de Expiración**: Verificación automática del estado de cookies con notificaciones en tiempo real\n- **Frontend Completo**: Panel administrativo profesional con login seguro y gestión de cookies\n\n## Funcionalidades del Panel\n- **Login Seguro**: Requiere token de administrador antes del acceso\n- **Estado en Tiempo Real**: Muestra balance, username, imagen de perfil y estado de partner\n- **Gestión de Cookies**: Actualización manual cuando sea necesario con validación automática\n- **API Protegida**: Todos los endpoints administrativos requieren autenticación por header\n\n# External Dependencies\n\n## Core Web Framework\n- **Flask**: Web application framework for API endpoints and admin panel\n- **Werkzeug**: WSGI utilities and HTTP request/response handling\n\n## TradingView Integration\n- **requests**: HTTP client for TradingView API communication\n- **urllib3**: Lower-level HTTP utilities for multipart form encoding\n\n## Date & Time Processing\n- **python-dateutil**: Advanced date parsing and relativedelta calculations for access period extensions\n\n## Hosting Platform\n- **Replit**: Cloud hosting platform providing:\n  - Built-in key-value database\n  - Environment variable management\n  - Automatic HTTPS and domain provisioning\n  - Zero-configuration deployment\n\n## Authentication & Security\n- **secrets**: Cryptographically secure random token generation for admin authentication","size_bytes":6324},"src/config.py":{"content":"urls = dict(\n  tvcoins=\"https://www.tradingview.com/tvcoins/details/\",\n  username_hint=\"https://www.tradingview.com/username_hint/\",\n  list_users=\"https://www.tradingview.com/pine_perm/list_users/\",\n  modify_access=\"https://www.tradingview.com/pine_perm/modify_user_expiration/\",\n  add_access=\"https://www.tradingview.com/pine_perm/add/\",\n  remove_access=\"https://www.tradingview.com/pine_perm/remove/\",\n  signin=\"https://www.tradingview.com/accounts/signin/\")\n","size_bytes":461},"src/helper.py":{"content":"from dateutil import parser\nfrom dateutil.relativedelta import relativedelta\ndef get_access_extension(currentExpirationDate:str, extension_type:str, extension_length:int):\n  expiration = parser.parse(currentExpirationDate)\n  if(extension_type=='Y'):\n    expiration = expiration + relativedelta(years=extension_length)\n  elif(extension_type=='M'):\n    expiration = expiration + relativedelta(months=extension_length)\n  elif(extension_type=='W'):\n    expiration = expiration + relativedelta(weeks=extension_length)\n  elif(extension_type=='D'):\n    expiration = expiration + relativedelta(days=extension_length)\n  return str(expiration)","size_bytes":633},"src/server.py":{"content":"from flask import Flask, request, render_template, jsonify, session, redirect, url_for\nfrom .tradingview import tradingview\nfrom .cookie_manager import CookieManager\nimport json\nimport os\nimport logging\nfrom datetime import datetime\nfrom functools import wraps\n#from threading import Thread\napp = Flask('')\n\n# Configure sessions for web navigation\napp.secret_key = os.getenv('SECRET_KEY', 'dev-secret-key-change-in-production')\napp.config['SESSION_COOKIE_SECURE'] = False  # True in production with HTTPS\napp.config['SESSION_COOKIE_HTTPONLY'] = True\napp.config['SESSION_COOKIE_SAMESITE'] = 'Lax'\n\n# PineScript Control Access - Phase 1 Core Functionality\nprint(\"🚀 PineScript Control Access - Starting core functionality\")\n\n# Initialize database and API routes now that dependencies are resolved\ntry:\n    from .database import db\n    print(\"✅ Database module loaded successfully\")\n    \n    # Register new API routes\n    from .routes.api_routes import api_bp\n    app.register_blueprint(api_bp)\n    print(\"✅ New API routes registered successfully\")\n    \nexcept Exception as e:\n    print(f\"⚠️ Advanced features failed to load: {e}\")\n    print(\"   Legacy API endpoints remain available\")\n\n# Disable access logging for production to prevent username leakage\nif os.getenv('ENV') == 'production':\n    logging.getLogger('werkzeug').setLevel(logging.WARNING)\n\n# Security: Admin authentication for API endpoints\ndef require_admin_token(f):\n    @wraps(f)\n    def decorated_function(*args, **kwargs):\n        # Check for authenticated session first\n        if session.get('authenticated'):\n            return f(*args, **kwargs)\n        \n        # Fall back to token authentication\n        admin_token = request.headers.get('X-Admin-Token')\n        expected_token = os.getenv('ADMIN_TOKEN')\n        \n        # Require ADMIN_TOKEN to be set\n        if not expected_token:\n            return jsonify({'error': 'Server misconfigured - ADMIN_TOKEN not set'}), 500\n        \n        if not admin_token or admin_token != expected_token:\n            return jsonify({'error': 'Unauthorized - Valid X-Admin-Token header required'}), 401\n        \n        return f(*args, **kwargs)\n    return decorated_function\n\n# Security: Web session authentication\ndef require_web_login(f):\n    @wraps(f)\n    def decorated_function(*args, **kwargs):\n        if 'authenticated' not in session or not session['authenticated']:\n            return redirect('/admin?redirect=' + request.path)\n        return f(*args, **kwargs)\n    return decorated_function\n\n# API endpoint for web login\n@app.route('/api/auth/login', methods=['POST'])\ndef web_login():\n    \"\"\"Web login endpoint\"\"\"\n    data = request.get_json()\n    token = data.get('token') if data else None\n    \n    if not token:\n        return jsonify({'error': 'Token required'}), 400\n    \n    expected_token = os.getenv('ADMIN_TOKEN')\n    if not expected_token:\n        return jsonify({'error': 'Server misconfigured'}), 500\n    \n    if token == expected_token:\n        session['authenticated'] = True\n        session['admin_token'] = token\n        return jsonify({'success': True, 'message': 'Authenticated successfully'})\n    else:\n        return jsonify({'error': 'Invalid token'}), 401\n\n@app.route('/api/auth/logout', methods=['POST'])\ndef web_logout():\n    \"\"\"Web logout endpoint\"\"\"\n    session.clear()\n    return jsonify({'success': True, 'message': 'Logged out successfully'})\n\n\n@app.route('/validate/<username>', methods=['GET'])\ndef validate(username):\n  try:\n    tv = tradingview()\n    response = tv.validate_username(username)\n    return json.dumps(response), 200, {\n      'Content-Type': 'application/json; charset=utf-8'\n    }\n  except Exception as e:\n    print(\"[X] Exception Occured : \", e)\n    failureResponse = {'errorMessage': 'Unknown Exception Occurred'}\n    return json.dumps(failureResponse), 500, {\n      'Content-Type': 'application/json; charset=utf-8'\n    }\n\n\n@app.route('/access/<username>', methods=['GET', 'POST', 'DELETE'])\n@require_admin_token\ndef access(username):\n  try:\n    # Solo leer JSON en métodos que tienen body\n    if request.method in ['POST', 'DELETE']:\n      jsonPayload = request.json or {}\n    else:\n      jsonPayload = {}\n      \n    # Nuevo formato para compatibilidad con pruebas\n    if 'indicator_id' in jsonPayload or request.method == 'GET':\n      # Formato de pruebas: indicator_id + days\n      indicator_id = jsonPayload.get('indicator_id')\n      days = jsonPayload.get('days')\n      \n      if request.method == 'GET':\n        # Verificar acceso real al indicador si se proporciona indicator_id en query params\n        indicator_id_param = request.args.get('indicator_id')\n        if indicator_id_param:\n          try:\n            tv = tradingview()\n            access = tv.get_access_details(username, indicator_id_param)\n            # Usar el campo correcto 'hasAccess' en lugar de 'results'\n            has_access = access.get('hasAccess', False) if isinstance(access, dict) else False\n            response = {\n              'username': username,\n              'has_access': has_access,\n              'status': 'checked',\n              'indicator_id': indicator_id_param,\n              'expiration': access.get('currentExpiration') if has_access else None,\n              'no_expiration': access.get('noExpiration', False) if has_access else False\n            }\n            return jsonify(response), 200\n          except Exception as e:\n            print(f\"Error checking access: {e}\")\n            response = {\n              'username': username,\n              'has_access': False,\n              'status': 'error',\n              'error': str(e)\n            }\n            return jsonify(response), 200\n        else:\n          # Respuesta simple sin indicador específico\n          response = {\n            'username': username,\n            'has_access': False,\n            'status': 'checked'\n          }\n          return jsonify(response), 200\n      \n      elif request.method == 'POST' and indicator_id and days:\n        # Otorgar acceso\n        try:\n          tv = tradingview()\n          access = tv.get_access_details(username, indicator_id)\n          # Formato correcto según documentación: Para 30 días usar 1M (1 mes)\n          if days == 30:\n            tv.add_access(access, 'M', 1)  # 1 mes = 30 días aproximadamente\n          else:\n            # Para otros valores usar días directamente  \n            tv.add_access(access, 'd', days)\n          return jsonify({'success': True, 'message': f'Access granted for {days} days'}), 200\n        except Exception as e:\n          print(f\"Error granting access: {e}\")\n          return jsonify({'success': False, 'error': str(e)}), 200\n      \n      elif request.method == 'DELETE' and indicator_id:\n        # Revocar acceso\n        try:\n          tv = tradingview()\n          access = tv.get_access_details(username, indicator_id)\n          tv.remove_access(access)\n          return jsonify({'success': True, 'message': 'Access revoked'}), 200\n        except Exception as e:\n          print(f\"Error revoking access: {e}\")\n          return jsonify({'success': False, 'error': str(e)}), 200\n    \n    # Formato original para retrocompatibilidad: pine_ids + duration\n    else:\n      tv = tradingview()\n      pine_ids = jsonPayload.get('pine_ids') or []\n      accessList = []\n      for pine_id in pine_ids:\n        access = tv.get_access_details(username, pine_id)\n        accessList = accessList + [access]\n\n      if request.method == 'POST':\n        duration = jsonPayload.get('duration')\n        if duration:\n          dNumber = int(duration[:-1])\n          dType = duration[-1:]\n          for access in accessList:\n            tv.add_access(access, dType, dNumber)\n\n      if request.method == 'DELETE':\n        for access in accessList:\n          tv.remove_access(access)\n      \n      return json.dumps(accessList), 200, {\n        'Content-Type': 'application/json; charset=utf-8'\n      }\n\n    return jsonify({'error': 'Invalid request format'}), 400\n\n  except Exception as e:\n    print(\"[X] Exception Occured : \", e)\n    failureResponse = {'errorMessage': 'Unknown Exception Occurred'}\n    return json.dumps(failureResponse), 500, {\n      'Content-Type': 'application/json; charset=utf-8'\n    }\n\n\n@app.route('/')\ndef main():\n  return 'Your bot is alive!'\n\n\n@app.route('/admin')\ndef admin_panel():\n  # Public access to serve the HTML - authentication happens via API calls\n  redirect_url = request.args.get('redirect', '')\n  return render_template('admin.html', redirect_url=redirect_url)\n\n# Web Dashboard Routes (require login)\n@app.route('/dashboard')\n@require_web_login\ndef dashboard():\n  \"\"\"Dashboard web interface\"\"\"\n  return render_template('dashboard.html')\n\n@app.route('/clients')\n@require_web_login\ndef clients():\n  \"\"\"Clients management web interface\"\"\"\n  return render_template('clients.html')\n\n@app.route('/indicators')\n@require_web_login\ndef indicators():\n  \"\"\"Indicators management web interface\"\"\"\n  return render_template('indicators.html')\n\n@app.route('/access')\n@require_web_login\ndef access_management():\n  \"\"\"Access management web interface\"\"\"\n  return render_template('access.html')\n\n\n@app.route('/doc')\ndef documentation():\n  # Public documentation endpoint\n  return render_template('documentation.html')\n\n\n@app.route('/api/v1/status')\ndef api_status():\n  \"\"\"Basic API status endpoint for PineScript Control Access\"\"\"\n  return jsonify({\n    'status': 'active',\n    'service': 'PineScript Control Access',\n    'version': '1.0.0-phase1',\n    'features': {\n      'legacy_api': 'active',\n      'management_suite': 'development',\n      'database': 'sqlite_ready'\n    },\n    'endpoints': {\n      'validate': '/validate/<username>',\n      'access': '/access/<username>',  \n      'admin': '/admin',\n      'documentation': '/doc'\n    }\n  })\n\n\n@app.route('/admin/cookies/status', methods=['GET'])\n@require_admin_token\ndef check_cookies_status():\n  try:\n    # Crear instancia de tradingview para verificar el estado\n    tv = tradingview()\n    \n    # Si llegamos aquí sin errores, las cookies son válidas\n    current_time = datetime.now().isoformat()\n    \n    # Obtener información completa de la cuenta\n    balance = getattr(tv, 'account_balance', '0.00')\n    username = getattr(tv, 'username', '')\n    partner_status = getattr(tv, 'partner_status', 0)\n    aff_id = getattr(tv, 'aff_id', 0)\n    profile_info = getattr(tv, 'profile_info', {})\n    \n    return jsonify({\n      'valid': True,\n      'lastCheck': current_time,\n      'balance': balance,\n      'username': username,\n      'partner_status': partner_status,\n      'aff_id': aff_id,\n      'profile_info': profile_info,\n      'status': 'authenticated'\n    })\n  except Exception as e:\n    current_time = datetime.now().isoformat()\n    return jsonify({\n      'valid': False,\n      'lastCheck': current_time,\n      'error': str(e),\n      'status': 'failed'\n    })\n\n\n@app.route('/admin/cookies/update', methods=['POST'])\n@require_admin_token\ndef update_cookies():\n  try:\n    data = request.json or {}\n    sessionid = data.get('sessionid', '').strip()\n    sessionid_sign = data.get('sessionid_sign', '').strip()\n    \n    if not sessionid or not sessionid_sign:\n      return jsonify({\n        'success': False,\n        'error': 'Both sessionid and sessionid_sign are required'\n      }), 400\n    \n    # Guardar en archivo JSON\n    cookie_manager = CookieManager()\n    if not cookie_manager.save_cookies(sessionid, sessionid_sign):\n      raise Exception(\"Failed to save cookies to JSON file\")\n    \n    # Verificar que las cookies funcionan creando una instancia\n    try:\n      test_tv = tradingview()\n      return jsonify({\n        'success': True,\n        'message': 'Cookies updated and verified successfully',\n        'timestamp': datetime.now().isoformat()\n      })\n    except Exception as test_error:\n      return jsonify({\n        'success': False,\n        'error': f'Cookies saved but failed verification: {str(test_error)}'\n      }), 400\n      \n  except Exception as e:\n    return jsonify({\n      'success': False,\n      'error': f'Failed to update cookies: {str(e)}'\n    }), 500\n\n\n# def run():\n#   app.run(host='0.0.0.0', port=5000)\n\n# def start_server_async():\n#   server = Thread(target=run)\n#   server.start()\n\n\ndef start_server():\n  app.run(host='0.0.0.0', port=5000)\n","size_bytes":12274},"src/tradingview.py":{"content":"import os\nfrom . import config\nimport requests\nimport platform\nfrom urllib3 import encode_multipart_formdata\nfrom datetime import datetime, timezone\nfrom . import helper\nfrom .cookie_manager import CookieManager\n\n\nclass tradingview:\n\n  def get_profile_info(self):\n    \"\"\"Get detailed profile information\"\"\"\n    try:\n      # Try different endpoints for user data\n      headers = {'cookie': self.cookies}\n      endpoints_to_try = [\n        f\"https://www.tradingview.com/pine_perm/get_author_data/?username={self.username}\",\n        f\"https://www.tradingview.com/u/{self.username}/\",\n        \"https://www.tradingview.com/accounts/me/\",\n        \"https://www.tradingview.com/social/user/\",\n      ]\n      \n      for endpoint in endpoints_to_try:\n        try:\n          response = requests.get(endpoint, headers=headers)\n          if response.status_code == 200:\n            # Try to parse as JSON first\n            try:\n              data = response.json()\n              if data and isinstance(data, dict) and len(data) > 0:\n                return data\n            except:\n              # If not JSON, check if HTML contains useful data\n              content = response.text\n              if 'userpic' in content or 'avatar' in content:\n                # Extract image URL from HTML if possible\n                import re\n                img_pattern = r'https://s3\\.tradingview\\.com/userpics/[^\"\\']*'\n                matches = re.findall(img_pattern, content)\n                if matches:\n                  profile_image = matches[0]\n                  return {'profile_image': profile_image, 'username': self.username}\n        except Exception as e:\n          continue\n          \n    except Exception as e:\n      return None\n    \n  def __init__(self):\n    print('Loading cookies from JSON file')\n    \n    # Initialize cookie manager\n    self.cookie_manager = CookieManager()\n    \n    # Try to get cookies from JSON file first\n    self.sessionid, self.sessionid_sign, _ = self.cookie_manager.load_cookies()\n    \n    if self.sessionid and self.sessionid_sign:\n      print('Using cookies from JSON file')\n      self.cookies = f'sessionid={self.sessionid}; sessionid_sign={self.sessionid_sign}'\n      \n      # Test if cookies are valid\n      headers = {'cookie': self.cookies}\n      test = requests.request(\"GET\", config.urls[\"tvcoins\"], headers=headers)\n      print(f'Cookie test response status: {test.status_code}')\n      \n      if test.status_code == 200:\n        print('JSON file cookies are valid')\n        try:\n          account_data = test.json()\n          self.account_balance = account_data.get('partner_fiat_balance', 0)\n          self.username = account_data.get('link', '')\n          self.partner_status = account_data.get('partner_status', 0)\n          self.aff_id = account_data.get('aff_id', 0)\n          print('Account data loaded successfully')\n          \n          # Try to get additional profile info\n          profile_info = self.get_profile_info()\n          if profile_info:\n            self.profile_info = profile_info\n        except:\n          self.account_balance = 0\n        return\n      else:\n        print('JSON file cookies are invalid, need manual update')\n        \n    # If no valid cookies, raise an error that requires manual intervention\n    print('No valid cookies found - please update through admin panel')\n    raise Exception('Invalid or expired TradingView session. Please update cookies through /admin panel.')\n\n  def validate_username(self, username):\n    users = requests.get(config.urls[\"username_hint\"] + \"?s=\" + username)\n    usersList = users.json()\n    validUser = False\n    verifiedUserName = ''\n    for user in usersList:\n      if user['username'].lower() == username.lower():\n        validUser = True\n        verifiedUserName = user['username']\n    return {\"validuser\": validUser, \"verifiedUserName\": verifiedUserName}\n\n  def get_access_details(self, username, pine_id):\n    user_payload = {'pine_id': pine_id, 'username': username}\n\n    user_headers = {\n      'origin': 'https://www.tradingview.com',\n      'Content-Type': 'application/x-www-form-urlencoded',\n      'Cookie': self.cookies\n    }\n    usersResponse = requests.post(config.urls['list_users'] +\n                                  '?limit=10&order_by=-created',\n                                  headers=user_headers,\n                                  data=user_payload)\n    userResponseJson = usersResponse.json()\n    print(f\"Access details request completed with status: {usersResponse.status_code}\")\n    users = userResponseJson['results']\n\n    access_details = user_payload\n    hasAccess = False\n    noExpiration = False\n    expiration = str(datetime.now(timezone.utc))\n    for user in users:\n      if user['username'].lower() == username.lower():\n        hasAccess = True\n        strExpiration = user.get(\"expiration\")\n        if strExpiration is not None:\n          expiration = user['expiration']\n        else:\n          noExpiration = True\n\n    access_details['hasAccess'] = hasAccess\n    access_details['noExpiration'] = noExpiration\n    access_details['currentExpiration'] = expiration\n    return access_details\n\n  def add_access(self, access_details, extension_type, extension_length):\n    noExpiration = access_details['noExpiration']\n    access_details['expiration'] = access_details['currentExpiration']\n    access_details['status'] = 'Not Applied'\n    if not noExpiration:\n      payload = {\n        'pine_id': access_details['pine_id'],\n        'username_recip': access_details['username']\n      }\n      if extension_type != 'L':\n        expiration = helper.get_access_extension(\n          access_details['currentExpiration'], extension_type,\n          extension_length)\n        payload['expiration'] = expiration\n        access_details['expiration'] = expiration\n      else:\n        access_details['noExpiration'] = True\n      enpoint_type = 'modify_access' if access_details[\n        'hasAccess'] else 'add_access'\n\n      body, contentType = encode_multipart_formdata(payload)\n\n      headers = {\n        'origin': 'https://www.tradingview.com',\n        'Content-Type': contentType,\n        'cookie': self.cookies\n      }\n      add_access_response = requests.post(config.urls[enpoint_type],\n                                          data=body,\n                                          headers=headers)\n      access_details['status'] = 'Success' if (\n        add_access_response.status_code == 200\n        or add_access_response.status_code == 201) else 'Failure'\n    return access_details\n\n  def remove_access(self, access_details):\n    payload = {\n      'pine_id': access_details['pine_id'],\n      'username_recip': access_details['username']\n    }\n    body, contentType = encode_multipart_formdata(payload)\n\n    headers = {\n      'origin': 'https://www.tradingview.com',\n      'Content-Type': contentType,\n      'cookie': self.cookies\n    }\n    remove_access_response = requests.post(config.urls['remove_access'],\n                                           data=body,\n                                           headers=headers)\n    access_details['status'] = 'Success' if (remove_access_response.status_code\n                                             == 200) else 'Failure'\n","size_bytes":7194},"src/cookie_manager.py":{"content":"import json\nimport os\nfrom datetime import datetime\n\nclass CookieManager:\n    def __init__(self, file_path=None):\n        # Allow configurable cookie file path via environment variable\n        self.file_path = file_path or os.getenv('COOKIE_FILE', 'data/cookies.json')\n        self.ensure_data_dir()\n    \n    def ensure_data_dir(self):\n        \"\"\"Crear directorio data/ si no existe\"\"\"\n        os.makedirs(os.path.dirname(self.file_path), exist_ok=True)\n    \n    def save_cookies(self, sessionid, sessionid_sign):\n        \"\"\"Guardar cookies en archivo JSON\"\"\"\n        data = {\n            'tv_sessionid': sessionid,\n            'tv_sessionid_sign': sessionid_sign,\n            'cookies_updated_at': datetime.now().isoformat()\n        }\n        \n        try:\n            # Ensure proper file permissions (read/write for owner only)\n            import stat\n            with open(self.file_path, 'w') as f:\n                json.dump(data, f, indent=2)\n            os.chmod(self.file_path, stat.S_IRUSR | stat.S_IWUSR)  # 600 permissions\n            return True\n        except Exception as e:\n            print(f\"Error saving cookies: {e}\")\n            return False\n    \n    def load_cookies(self):\n        \"\"\"Cargar cookies desde archivo JSON\"\"\"\n        if not os.path.exists(self.file_path):\n            return '', '', None\n            \n        try:\n            with open(self.file_path, 'r') as f:\n                data = json.load(f)\n            return (\n                data.get('tv_sessionid', ''),\n                data.get('tv_sessionid_sign', ''),\n                data.get('cookies_updated_at')\n            )\n        except Exception as e:\n            print(f\"Error loading cookies: {e}\")\n            return '', '', None\n    \n    def get_cookie(self, key, default=''):\n        \"\"\"Obtener un valor específico de cookie\"\"\"\n        sessionid, sessionid_sign, updated_at = self.load_cookies()\n        \n        if key == 'tv_sessionid':\n            return sessionid\n        elif key == 'tv_sessionid_sign':\n            return sessionid_sign\n        elif key == 'cookies_updated_at':\n            return updated_at\n        else:\n            return default\n    \n    def cookies_exist(self):\n        \"\"\"Verificar si existen cookies guardadas\"\"\"\n        sessionid, sessionid_sign, _ = self.load_cookies()\n        return bool(sessionid and sessionid_sign)\n    \n    def clear_cookies(self):\n        \"\"\"Limpiar archivo de cookies\"\"\"\n        try:\n            if os.path.exists(self.file_path):\n                os.remove(self.file_path)\n            return True\n        except Exception as e:\n            print(f\"Error clearing cookies: {e}\")\n            return False","size_bytes":2655},"ROADMAP.md":{"content":"# 🚀 TradingView Indicator Management Suite - Roadmap\n\n## 📋 Visión General\n\nEvolucionar el actual servicio de API básico hacia una **plataforma completa de gestión de indicadores de TradingView**, permitiendo a vendedores gestionar de forma profesional sus clientes, productos y suscripciones.\n\n---\n\n## 🏗️ FASE 1: Core Management Platform\n\n### 🎯 Objetivo\nCrear la base sólida del sistema con funcionalidades esenciales de gestión.\n\n### 📊 1.1 Base de Datos Local\n**Prioridad: Alta** | **Estimado: 1-2 semanas**\n\n#### Modelos de datos:\n- **Indicadores**\n  - `id`, `nombre`, `version`, `ultima_actualizacion`, `pub_id`, `estado`, `descripcion`\n- **Clientes** \n  - `id`, `username_tradingview`, `email`, `nombre_completo`, `fecha_registro`, `estado`\n- **Accesos**\n  - `id`, `cliente_id`, `indicador_id`, `fecha_inicio`, `fecha_fin`, `estado`, `tipo_acceso`\n\n#### Tecnología:\n- SQLite para simplicidad en Replit\n- SQLAlchemy ORM para Python\n- Migrations automáticas\n\n### 🏢 1.2 CRM Básico - Gestión de Clientes\n**Prioridad: Alta** | **Estimado: 1 semana**\n\n#### Funcionalidades:\n- ✅ CRUD completo de clientes\n- ✅ Lista con filtros (activo/inactivo, fecha registro)\n- ✅ Búsqueda por nombre/email/username\n- ✅ Vista de perfil del cliente con historial de accesos\n- ✅ Validación automática de username en TradingView\n\n#### Interfaz:\n- Panel web responsive\n- Tablas interactivas con paginación\n- Formularios de alta/edición\n\n### 📦 1.3 Catálogo de Productos - Gestión de Indicadores  \n**Prioridad: Alta** | **Estimado: 1 semana**\n\n#### Funcionalidades:\n- ✅ CRUD de indicadores propios\n- ✅ Control de versiones\n- ✅ Estados (desarrollo, producción, retirado)\n- ✅ Validación de PUB IDs contra TradingView\n- ✅ Métricas básicas por indicador (usuarios activos)\n\n#### Datos almacenados:\n- Información técnica del indicador\n- Historial de versiones\n- Estadísticas de uso\n\n### ⏰ 1.4 Sistema de Suscripciones - Control de Accesos\n**Prioridad: Alta** | **Estimado: 1-2 semanas**\n\n#### Funcionalidades:\n- ✅ Asignación múltiple (cliente + indicadores + duración)\n- ✅ Vista calendario de vencimientos\n- ✅ Renovación manual con opciones predefinidas (7d, 30d, 90d, lifetime)\n- ✅ Estados: activo, por vencer, vencido, revocado\n- ✅ Sincronización automática con TradingView API\n\n#### Dashboard de accesos:\n- Vista general de suscripciones activas\n- Alertas de próximos vencimientos (7 días, 1 día)\n- Historial completo de cambios\n\n### 📈 1.5 Analytics Básico - Métricas Esenciales\n**Prioridad: Media** | **Estimado: 1 semana**\n\n#### Métricas implementadas:\n- ✅ Total de clientes (activos/todos)\n- ✅ Indicadores más populares\n- ✅ Suscripciones por mes\n- ✅ Tasa de renovación\n- ✅ Próximos vencimientos (dashboard)\n\n#### Visualización:\n- Gráficos simples con Chart.js\n- KPIs principales en dashboard\n- Tablas de resumen\n\n### 🔄 1.6 Automatización Básica\n**Prioridad: Media** | **Estimado: 1 semana**\n\n#### Funcionalidades:\n- ✅ Detección automática de accesos próximos a vencer\n- ✅ Marcado automático de accesos vencidos\n- ✅ Sincronización diaria con TradingView API\n- ✅ Logging de todas las operaciones críticas\n\n#### Implementación:\n- Jobs programados internos\n- Sistema de notificaciones en dashboard\n- Logs estructurados para auditoría\n\n---\n\n## 🚀 FASE 2: Funcionalidades Avanzadas\n\n### 🎯 Objetivo\nAgregar automatización avanzada y herramientas de negocio profesionales.\n\n### 💳 2.1 Integración con Sistemas de Pago\n**Prioridad: Media** | **Estimado: 2-3 semanas**\n\n#### Funcionalidades:\n- Integración con Stripe\n- Enlaces de pago personalizados\n- Renovación automática de suscripciones\n- Webhooks para confirmación de pagos\n- Panel de transacciones\n\n### 📊 2.2 Reportes y Exportación\n**Prioridad: Media** | **Estimado: 1-2 semanas**\n\n#### Reportes disponibles:\n- Reporte de ventas (mensual/anual)\n- Lista de clientes (CSV/PDF)\n- Historial de accesos por cliente\n- Métricas de rendimiento de indicadores\n\n### 📧 2.3 Sistema de Notificaciones\n**Prioridad: Media** | **Estimado: 1-2 semanas**\n\n#### Canales:\n- Email automático a clientes\n- Notificaciones internas (dashboard)\n- Opcional: integración con WhatsApp/Telegram\n\n#### Eventos:\n- Acceso próximo a vencer\n- Acceso renovado\n- Nuevo registro de cliente\n\n### 🔐 2.4 Multi-usuario y Roles\n**Prioridad: Baja** | **Estimado: 2 semanas**\n\n#### Roles:\n- **Admin**: acceso completo\n- **Vendedor**: gestión de clientes y accesos\n- **Soporte**: solo lectura y renovaciones\n\n### 📱 2.5 API Pública Expandida\n**Prioridad: Baja** | **Estimado: 1 semana**\n\n#### Nuevos endpoints:\n- Webhook para terceros\n- API de consulta para integraciones\n- Autenticación por API key\n\n---\n\n## 🛠️ Consideraciones Técnicas\n\n### Base de Datos\n```sql\n-- Estructura principal\nClientes (id, username_tv, email, nombre, fecha_registro, estado)\nIndicadores (id, nombre, version, pub_id, fecha_actualizacion, estado)\nAccesos (id, cliente_id, indicador_id, fecha_inicio, fecha_fin, estado)\nTransacciones (id, cliente_id, monto, fecha, estado, referencia_pago)\n```\n\n### Stack Tecnológico\n- **Backend**: Flask + SQLAlchemy (actual)\n- **Frontend**: HTML/CSS/JavaScript (actual) con mejoras incrementales  \n- **Base de Datos**: SQLite → PostgreSQL (si crece)\n- **Integraciones**: Replit integrations para Stripe, email, etc.\n\n### Arquitectura\n```\n/src\n  /models          # SQLAlchemy models\n  /routes          # API endpoints organizados\n  /services        # Business logic\n  /utils           # Helpers y utilidades\n  /static          # CSS/JS mejorado\n/templates\n  /admin           # Panels administrativos\n  /client          # Vistas para clientes (fase 2)\n/migrations        # DB migrations\n/tests            # Unit tests (fase 2)\n```\n\n---\n\n## 📅 Cronograma Estimado\n\n### Fase 1 (6-8 semanas)\n- **Semana 1-2**: Base de datos + modelos básicos\n- **Semana 3**: CRM básico (gestión clientes) \n- **Semana 4**: Catálogo de indicadores\n- **Semana 5-6**: Sistema de suscripciones\n- **Semana 7**: Analytics básico  \n- **Semana 8**: Automatización + testing\n\n### Fase 2 (4-6 semanas adicionales)\n- Basado en feedback de Fase 1\n- Priorización según necesidades del negocio\n\n---\n\n## 🎯 Criterios de Éxito - Fase 1\n\n### Funcionales:\n- [ ] Gestionar 100+ clientes sin problemas de rendimiento\n- [ ] Sincronización 99.9% exitosa con TradingView API\n- [ ] Interface web responsive en móvil y desktop\n- [ ] Tiempo de respuesta < 2 segundos en operaciones comunes\n\n### Técnicos:\n- [ ] Cobertura de tests > 80% (fase 2)\n- [ ] Zero downtime en actualizaciones\n- [ ] Backup automático de base de datos\n- [ ] Logs estructurados para debugging\n\n### Negocio:\n- [ ] Reducir tiempo de gestión manual en 80%\n- [ ] Eliminar errores humanos en asignación de accesos\n- [ ] Visibilidad completa del negocio (métricas)\n- [ ] Base sólida para escalamiento futuro\n\n---\n\n## 💡 Ideas Futuras (Fase 3+)\n\n- **Mobile App**: aplicación móvil para gestión\n- **Client Portal**: portal para que clientes vean sus accesos\n- **Advanced Analytics**: ML para predicción de renovaciones\n- **Marketplace Integration**: conectar con otros marketplaces\n- **API Marketplace**: monetizar API para otros vendedores\n\n---\n\n*Última actualización: Septiembre 2025*\n*Estado actual: ✅ API básica completada → Iniciar Fase 1*","size_bytes":7351},"src/database.py":{"content":"import sqlite3\nimport os\nfrom datetime import datetime\nfrom typing import Optional, List, Dict, Any\n\nclass Database:\n    \"\"\"Simple SQLite database manager for PineScript Control Access\"\"\"\n    \n    def __init__(self, db_path: str = \"data/pinescript_control.db\"):\n        self.db_path = db_path\n        self.ensure_db_directory()\n        self.init_database()\n    \n    def ensure_db_directory(self):\n        \"\"\"Create database directory if it doesn't exist\"\"\"\n        os.makedirs(os.path.dirname(self.db_path), exist_ok=True)\n    \n    def get_connection(self) -> sqlite3.Connection:\n        \"\"\"Get database connection with foreign keys enabled\"\"\"\n        conn = sqlite3.connect(self.db_path)\n        conn.execute(\"PRAGMA foreign_keys = ON\")\n        conn.row_factory = sqlite3.Row  # Enable dict-like access to rows\n        return conn\n    \n    def init_database(self):\n        \"\"\"Initialize database with all tables\"\"\"\n        with self.get_connection() as conn:\n            # Migrate existing tables - Add precio column if it doesn't exist\n            self._migrate_add_precio_column(conn)\n            # Create Indicadores table\n            conn.execute(\"\"\"\n                CREATE TABLE IF NOT EXISTS indicadores (\n                    id INTEGER PRIMARY KEY AUTOINCREMENT,\n                    nombre VARCHAR(200) NOT NULL,\n                    version VARCHAR(50) DEFAULT '1.0',\n                    pub_id VARCHAR(100) UNIQUE NOT NULL,\n                    precio DECIMAL(10,2) DEFAULT 0.00,\n                    descripcion TEXT,\n                    estado VARCHAR(20) DEFAULT 'activo',\n                    fecha_creacion TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                    ultima_actualizacion TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n                )\n            \"\"\")\n            \n            # Create Clientes table\n            conn.execute(\"\"\"\n                CREATE TABLE IF NOT EXISTS clientes (\n                    id INTEGER PRIMARY KEY AUTOINCREMENT,\n                    username_tradingview VARCHAR(100) UNIQUE NOT NULL,\n                    email VARCHAR(255),\n                    nombre_completo VARCHAR(200),\n                    fecha_registro TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                    estado VARCHAR(20) DEFAULT 'activo',\n                    notas TEXT\n                )\n            \"\"\")\n            \n            # Create Accesos table\n            conn.execute(\"\"\"\n                CREATE TABLE IF NOT EXISTS accesos (\n                    id INTEGER PRIMARY KEY AUTOINCREMENT,\n                    cliente_id INTEGER NOT NULL,\n                    indicador_id INTEGER NOT NULL,\n                    fecha_inicio TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                    fecha_fin TIMESTAMP,\n                    estado VARCHAR(20) DEFAULT 'activo',\n                    tipo_acceso VARCHAR(50) DEFAULT 'temporal',\n                    notas TEXT,\n                    fecha_creacion TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                    FOREIGN KEY (cliente_id) REFERENCES clientes (id) ON DELETE CASCADE,\n                    FOREIGN KEY (indicador_id) REFERENCES indicadores (id) ON DELETE CASCADE\n                )\n            \"\"\")\n            \n            # Create indexes for better performance\n            conn.execute(\"CREATE INDEX IF NOT EXISTS idx_accesos_cliente ON accesos (cliente_id)\")\n            conn.execute(\"CREATE INDEX IF NOT EXISTS idx_accesos_indicador ON accesos (indicador_id)\")\n            conn.execute(\"CREATE INDEX IF NOT EXISTS idx_accesos_estado ON accesos (estado)\")\n            conn.execute(\"CREATE INDEX IF NOT EXISTS idx_clientes_username ON clientes (username_tradingview)\")\n            conn.execute(\"CREATE INDEX IF NOT EXISTS idx_indicadores_pub_id ON indicadores (pub_id)\")\n            \n            conn.commit()\n            print(\"✅ Database initialized successfully\")\n    \n    def _migrate_add_precio_column(self, conn):\n        \"\"\"Add precio column to indicadores table if it doesn't exist\"\"\"\n        try:\n            # Check if precio column exists\n            cursor = conn.execute(\"PRAGMA table_info(indicadores)\")\n            columns = [column[1] for column in cursor.fetchall()]\n            \n            if 'precio' not in columns:\n                print(\"🔄 Adding precio column to indicadores table...\")\n                conn.execute(\"ALTER TABLE indicadores ADD COLUMN precio DECIMAL(10,2) DEFAULT 0.00\")\n                print(\"✅ Added precio column successfully\")\n        except Exception as e:\n            print(f\"⚠️ Migration warning (precio column): {e}\")\n    \n    def execute_query(self, query: str, params: tuple = ()) -> List[Dict[str, Any]]:\n        \"\"\"Execute a SELECT query and return results as list of dicts\"\"\"\n        with self.get_connection() as conn:\n            cursor = conn.execute(query, params)\n            columns = [description[0] for description in cursor.description]\n            return [dict(zip(columns, row)) for row in cursor.fetchall()]\n    \n    def execute_insert(self, query: str, params: tuple = ()) -> int:\n        \"\"\"Execute an INSERT query and return the last row id\"\"\"\n        with self.get_connection() as conn:\n            cursor = conn.execute(query, params)\n            conn.commit()\n            return cursor.lastrowid\n    \n    def execute_update(self, query: str, params: tuple = ()) -> int:\n        \"\"\"Execute an UPDATE/DELETE query and return affected rows count\"\"\"\n        with self.get_connection() as conn:\n            cursor = conn.execute(query, params)\n            conn.commit()\n            return cursor.rowcount\n    \n    def get_stats(self) -> Dict[str, int]:\n        \"\"\"Get basic statistics about the database\"\"\"\n        stats = {}\n        \n        # Count tables\n        stats['total_indicadores'] = self.execute_query(\"SELECT COUNT(*) as count FROM indicadores\")[0]['count']\n        stats['indicadores_activos'] = self.execute_query(\"SELECT COUNT(*) as count FROM indicadores WHERE estado = 'activo'\")[0]['count']\n        \n        stats['total_clientes'] = self.execute_query(\"SELECT COUNT(*) as count FROM clientes\")[0]['count']\n        stats['clientes_activos'] = self.execute_query(\"SELECT COUNT(*) as count FROM clientes WHERE estado = 'activo'\")[0]['count']\n        \n        stats['total_accesos'] = self.execute_query(\"SELECT COUNT(*) as count FROM accesos\")[0]['count']\n        stats['accesos_activos'] = self.execute_query(\"SELECT COUNT(*) as count FROM accesos WHERE estado = 'activo'\")[0]['count']\n        \n        # Próximos a vencer (próximos 7 días)\n        stats['proximos_vencimientos'] = self.execute_query(\"\"\"\n            SELECT COUNT(*) as count FROM accesos \n            WHERE estado = 'activo' \n            AND fecha_fin IS NOT NULL \n            AND fecha_fin <= datetime('now', '+7 days')\n        \"\"\")[0]['count']\n        \n        return stats\n\n# Global database instance\ndb = Database()","size_bytes":6841},"src/models.py":{"content":"from datetime import datetime, timedelta\nfrom typing import Optional, List, Dict, Any\nfrom .database import db\n\nclass BaseModel:\n    \"\"\"Base model with common functionality\"\"\"\n    table_name = \"\"\n    \n    @classmethod\n    def create(cls, **kwargs) -> int:\n        \"\"\"Create a new record and return its ID\"\"\"\n        # Filter only valid columns for this table\n        filtered_kwargs = cls._filter_columns(**kwargs)\n        \n        columns = list(filtered_kwargs.keys())\n        placeholders = ['?' for _ in columns]\n        values = list(filtered_kwargs.values())\n        \n        query = f\"\"\"\n            INSERT INTO {cls.table_name} ({', '.join(columns)}) \n            VALUES ({', '.join(placeholders)})\n        \"\"\"\n        \n        return db.execute_insert(query, tuple(values))\n    \n    @classmethod\n    def get_by_id(cls, record_id: int) -> Optional[Dict[str, Any]]:\n        \"\"\"Get a record by ID\"\"\"\n        query = f\"SELECT * FROM {cls.table_name} WHERE id = ?\"\n        results = db.execute_query(query, (record_id,))\n        return results[0] if results else None\n    \n    @classmethod\n    def get_all(cls, where_clause: str = \"\", params: tuple = ()) -> List[Dict[str, Any]]:\n        \"\"\"Get all records, optionally with WHERE clause\"\"\"\n        query = f\"SELECT * FROM {cls.table_name}\"\n        if where_clause:\n            query += f\" WHERE {where_clause}\"\n        query += \" ORDER BY id DESC\"\n        \n        return db.execute_query(query, params)\n    \n    @classmethod\n    def update(cls, record_id: int, **kwargs) -> bool:\n        \"\"\"Update a record by ID\"\"\"\n        filtered_kwargs = cls._filter_columns(**kwargs)\n        \n        if not filtered_kwargs:\n            return False\n            \n        set_clause = ', '.join([f\"{col} = ?\" for col in filtered_kwargs.keys()])\n        values = list(filtered_kwargs.values()) + [record_id]\n        \n        query = f\"UPDATE {cls.table_name} SET {set_clause} WHERE id = ?\"\n        return db.execute_update(query, tuple(values)) > 0\n    \n    @classmethod\n    def delete(cls, record_id: int) -> bool:\n        \"\"\"Delete a record by ID\"\"\"\n        query = f\"DELETE FROM {cls.table_name} WHERE id = ?\"\n        return db.execute_update(query, (record_id,)) > 0\n    \n    @classmethod\n    def _filter_columns(cls, **kwargs) -> Dict[str, Any]:\n        \"\"\"Filter kwargs to include only valid columns - override in subclasses\"\"\"\n        return kwargs\n\nclass Indicador(BaseModel):\n    \"\"\"Model for managing TradingView indicators\"\"\"\n    table_name = \"indicadores\"\n    \n    @classmethod\n    def _filter_columns(cls, **kwargs) -> Dict[str, Any]:\n        valid_columns = {\n            'nombre', 'version', 'pub_id', 'precio', 'descripcion', 'estado', 'ultima_actualizacion'\n        }\n        return {k: v for k, v in kwargs.items() if k in valid_columns}\n    \n    @classmethod\n    def get_by_pub_id(cls, pub_id: str) -> Optional[Dict[str, Any]]:\n        \"\"\"Get indicator by PUB ID\"\"\"\n        query = f\"SELECT * FROM {cls.table_name} WHERE pub_id = ?\"\n        results = db.execute_query(query, (pub_id,))\n        return results[0] if results else None\n    \n    @classmethod\n    def get_active(cls) -> List[Dict[str, Any]]:\n        \"\"\"Get all active indicators\"\"\"\n        return cls.get_all(\"estado = 'activo'\")\n    \n    @classmethod\n    def search(cls, term: str) -> List[Dict[str, Any]]:\n        \"\"\"Search indicators by name or description\"\"\"\n        query = f\"\"\"\n            SELECT * FROM {cls.table_name} \n            WHERE nombre LIKE ? OR descripcion LIKE ? OR pub_id LIKE ?\n            ORDER BY nombre\n        \"\"\"\n        search_term = f\"%{term}%\"\n        return db.execute_query(query, (search_term, search_term, search_term))\n\nclass Cliente(BaseModel):\n    \"\"\"Model for managing clients\"\"\"\n    table_name = \"clientes\"\n    \n    @classmethod\n    def _filter_columns(cls, **kwargs) -> Dict[str, Any]:\n        valid_columns = {\n            'username_tradingview', 'email', 'nombre_completo', 'estado', 'notas'\n        }\n        return {k: v for k, v in kwargs.items() if k in valid_columns}\n    \n    @classmethod\n    def get_by_username(cls, username: str) -> Optional[Dict[str, Any]]:\n        \"\"\"Get client by TradingView username\"\"\"\n        query = f\"SELECT * FROM {cls.table_name} WHERE username_tradingview = ?\"\n        results = db.execute_query(query, (username,))\n        return results[0] if results else None\n    \n    @classmethod\n    def get_active(cls) -> List[Dict[str, Any]]:\n        \"\"\"Get all active clients\"\"\"\n        return cls.get_all(\"estado = 'activo'\")\n    \n    @classmethod\n    def search(cls, term: str) -> List[Dict[str, Any]]:\n        \"\"\"Search clients by username, email, or name\"\"\"\n        query = f\"\"\"\n            SELECT * FROM {cls.table_name} \n            WHERE username_tradingview LIKE ? OR email LIKE ? OR nombre_completo LIKE ?\n            ORDER BY username_tradingview\n        \"\"\"\n        search_term = f\"%{term}%\"\n        return db.execute_query(query, (search_term, search_term, search_term))\n    \n    @classmethod\n    def get_with_access_count(cls) -> List[Dict[str, Any]]:\n        \"\"\"Get clients with their active access count\"\"\"\n        query = \"\"\"\n            SELECT c.*, \n                   COUNT(a.id) as accesos_activos\n            FROM clientes c\n            LEFT JOIN accesos a ON c.id = a.cliente_id AND a.estado = 'activo'\n            GROUP BY c.id\n            ORDER BY c.username_tradingview\n        \"\"\"\n        return db.execute_query(query)\n\nclass Acceso(BaseModel):\n    \"\"\"Model for managing access permissions\"\"\"\n    table_name = \"accesos\"\n    \n    @classmethod\n    def _filter_columns(cls, **kwargs) -> Dict[str, Any]:\n        valid_columns = {\n            'cliente_id', 'indicador_id', 'fecha_inicio', 'fecha_fin', \n            'estado', 'tipo_acceso', 'notas'\n        }\n        return {k: v for k, v in kwargs.items() if k in valid_columns}\n    \n    @classmethod\n    def get_by_client_and_indicator(cls, cliente_id: int, indicador_id: int) -> Optional[Dict[str, Any]]:\n        \"\"\"Get access record for specific client and indicator\"\"\"\n        query = f\"\"\"\n            SELECT * FROM {cls.table_name} \n            WHERE cliente_id = ? AND indicador_id = ? AND estado = 'activo'\n        \"\"\"\n        results = db.execute_query(query, (cliente_id, indicador_id))\n        return results[0] if results else None\n    \n    @classmethod\n    def get_client_accesses(cls, cliente_id: int) -> List[Dict[str, Any]]:\n        \"\"\"Get all accesses for a specific client with indicator details\"\"\"\n        query = \"\"\"\n            SELECT a.*, i.nombre as indicador_nombre, i.pub_id\n            FROM accesos a\n            JOIN indicadores i ON a.indicador_id = i.id\n            WHERE a.cliente_id = ?\n            ORDER BY a.fecha_creacion DESC\n        \"\"\"\n        return db.execute_query(query, (cliente_id,))\n    \n    @classmethod\n    def get_indicator_accesses(cls, indicador_id: int) -> List[Dict[str, Any]]:\n        \"\"\"Get all accesses for a specific indicator with client details\"\"\"\n        query = \"\"\"\n            SELECT a.*, c.username_tradingview, c.nombre_completo\n            FROM accesos a\n            JOIN clientes c ON a.cliente_id = c.id\n            WHERE a.indicador_id = ?\n            ORDER BY a.fecha_creacion DESC\n        \"\"\"\n        return db.execute_query(query, (indicador_id,))\n    \n    @classmethod\n    def get_active_accesses(cls) -> List[Dict[str, Any]]:\n        \"\"\"Get all active accesses with client and indicator details\"\"\"\n        query = \"\"\"\n            SELECT a.*, \n                   c.username_tradingview, c.nombre_completo,\n                   i.nombre as indicador_nombre, i.pub_id\n            FROM accesos a\n            JOIN clientes c ON a.cliente_id = c.id\n            JOIN indicadores i ON a.indicador_id = i.id\n            WHERE a.estado = 'activo'\n            ORDER BY a.fecha_fin ASC\n        \"\"\"\n        return db.execute_query(query)\n    \n    @classmethod\n    def get_expiring_soon(cls, days: int = 7) -> List[Dict[str, Any]]:\n        \"\"\"Get accesses expiring in the next N days\"\"\"\n        query = \"\"\"\n            SELECT a.*, \n                   c.username_tradingview, c.nombre_completo,\n                   i.nombre as indicador_nombre, i.pub_id\n            FROM accesos a\n            JOIN clientes c ON a.cliente_id = c.id\n            JOIN indicadores i ON a.indicador_id = i.id\n            WHERE a.estado = 'activo' \n            AND a.fecha_fin IS NOT NULL \n            AND a.fecha_fin <= datetime('now', '+{days} days')\n            ORDER BY a.fecha_fin ASC\n        \"\"\"\n        return db.execute_query(query)\n    \n    @classmethod\n    def get_expired(cls) -> List[Dict[str, Any]]:\n        \"\"\"Get expired accesses that need to be marked as expired\"\"\"\n        query = \"\"\"\n            SELECT a.*, \n                   c.username_tradingview, c.nombre_completo,\n                   i.nombre as indicador_nombre, i.pub_id\n            FROM accesos a\n            JOIN clientes c ON a.cliente_id = c.id\n            JOIN indicadores i ON a.indicador_id = i.id\n            WHERE a.estado = 'activo' \n            AND a.fecha_fin IS NOT NULL \n            AND a.fecha_fin <= datetime('now')\n            ORDER BY a.fecha_fin DESC\n        \"\"\"\n        return db.execute_query(query)\n    \n    @classmethod\n    def grant_access(cls, cliente_id: int, indicador_id: int, days: int, tipo_acceso: str = \"temporal\") -> int:\n        \"\"\"Grant access to a client for specific days\"\"\"\n        fecha_inicio = datetime.now()\n        fecha_fin = fecha_inicio + timedelta(days=days) if days > 0 else None\n        \n        # Check if there's already an active access\n        existing = cls.get_by_client_and_indicator(cliente_id, indicador_id)\n        if existing:\n            # Update existing access\n            cls.update(existing['id'], \n                      fecha_fin=fecha_fin.isoformat() if fecha_fin else None,\n                      tipo_acceso=tipo_acceso,\n                      notas=f\"Renovado por {days} días\" if days > 0 else \"Convertido a acceso permanente\")\n            return existing['id']\n        else:\n            # Create new access\n            return cls.create(\n                cliente_id=cliente_id,\n                indicador_id=indicador_id,\n                fecha_inicio=fecha_inicio.isoformat(),\n                fecha_fin=fecha_fin.isoformat() if fecha_fin else None,\n                tipo_acceso=tipo_acceso,\n                notas=f\"Acceso inicial por {days} días\" if days > 0 else \"Acceso permanente\"\n            )\n    \n    @classmethod\n    def revoke_access(cls, cliente_id: int, indicador_id: int) -> bool:\n        \"\"\"Revoke access for a client to specific indicator\"\"\"\n        existing = cls.get_by_client_and_indicator(cliente_id, indicador_id)\n        if existing:\n            return cls.update(existing['id'], estado='revocado', notas=\"Acceso revocado manualmente\")\n        return False\n    \n    @classmethod\n    def mark_expired(cls) -> int:\n        \"\"\"Mark expired accesses as expired and return count\"\"\"\n        query = \"\"\"\n            UPDATE accesos \n            SET estado = 'expirado' \n            WHERE estado = 'activo' \n            AND fecha_fin IS NOT NULL \n            AND fecha_fin <= datetime('now')\n        \"\"\"\n        return db.execute_update(query)","size_bytes":11190},"src/services.py":{"content":"\"\"\"\nBusiness logic services for PineScript Control Access\n\"\"\"\nfrom typing import Dict, List, Any, Optional\nfrom .models import Indicador, Cliente, Acceso\nfrom .tradingview import tradingview\n\nclass IndicadorService:\n    \"\"\"Service for managing indicators\"\"\"\n    \n    @staticmethod\n    def create_indicator(nombre: str, pub_id: str, precio: float = 0.0, version: str = \"1.0\", descripcion: str = \"\") -> int:\n        \"\"\"Create a new indicator\"\"\"\n        return Indicador.create(\n            nombre=nombre,\n            pub_id=pub_id,\n            precio=precio,\n            version=version,\n            descripcion=descripcion\n        )\n    \n    @staticmethod\n    def get_all_indicators() -> List[Dict[str, Any]]:\n        \"\"\"Get all indicators\"\"\"\n        return Indicador.get_all()\n    \n    @staticmethod\n    def get_active_indicators() -> List[Dict[str, Any]]:\n        \"\"\"Get only active indicators\"\"\"\n        return Indicador.get_active()\n    \n    @staticmethod\n    def search_indicators(term: str) -> List[Dict[str, Any]]:\n        \"\"\"Search indicators by name or description\"\"\"\n        return Indicador.search(term)\n    \n    @staticmethod\n    def update_indicator(indicator_id: int, **kwargs) -> bool:\n        \"\"\"Update an indicator\"\"\"\n        return Indicador.update(indicator_id, **kwargs)\n    \n    @staticmethod\n    def delete_indicator(indicator_id: int) -> bool:\n        \"\"\"Delete an indicator (soft delete by setting estado to 'inactivo')\"\"\"\n        return Indicador.update(indicator_id, estado='inactivo')\n    \n    @staticmethod\n    def get_indicator_stats(indicator_id: int) -> Dict[str, Any]:\n        \"\"\"Get statistics for a specific indicator\"\"\"\n        indicator = Indicador.get_by_id(indicator_id)\n        if not indicator:\n            return {}\n        \n        accesses = Acceso.get_indicator_accesses(indicator_id)\n        active_accesses = [a for a in accesses if a['estado'] == 'activo']\n        \n        return {\n            'indicator': indicator,\n            'total_accesses': len(accesses),\n            'active_accesses': len(active_accesses),\n            'expired_accesses': len([a for a in accesses if a['estado'] == 'expirado']),\n            'revoked_accesses': len([a for a in accesses if a['estado'] == 'revocado']),\n            'recent_accesses': accesses[:10]  # Last 10\n        }\n\nclass ClienteService:\n    \"\"\"Service for managing clients\"\"\"\n    \n    @staticmethod\n    def create_client(username_tradingview: str, email: str = \"\", nombre_completo: str = \"\") -> Dict[str, Any]:\n        \"\"\"Create a new client with TradingView validation\"\"\"\n        result = {'success': False, 'message': '', 'client_id': None}\n        \n        # Check if client already exists\n        existing = Cliente.get_by_username(username_tradingview)\n        if existing:\n            if existing.get('estado') == 'activo':\n                result['message'] = 'Cliente ya existe con ese username de TradingView'\n                return result\n            else:\n                # Reactivate inactive client\n                try:\n                    updated = Cliente.update(existing['id'], \n                                           estado='activo',\n                                           email=email or existing['email'],\n                                           nombre_completo=nombre_completo or existing['nombre_completo'])\n                    if updated:\n                        result['success'] = True\n                        result['client_id'] = existing['id']\n                        result['message'] = 'Cliente reactivado exitosamente'\n                        return result\n                    else:\n                        result['message'] = 'Error reactivando cliente'\n                        return result\n                except Exception as e:\n                    result['message'] = f'Error reactivating client: {str(e)}'\n                    return result\n        \n        # Validate username with TradingView API for new clients\n        try:\n            tv = tradingview()\n            validation = tv.validate_username(username_tradingview)\n            \n            if not validation.get('validuser', False):\n                result['message'] = 'Username no válido en TradingView'\n                return result\n                \n        except Exception as e:\n            result['message'] = f'Error validating username: {str(e)}'\n            return result\n        \n        # Create new client\n        try:\n            client_id = Cliente.create(\n                username_tradingview=username_tradingview,\n                email=email,\n                nombre_completo=nombre_completo\n            )\n            \n            result['success'] = True\n            result['client_id'] = client_id\n            result['message'] = 'Cliente creado exitosamente'\n            \n        except Exception as e:\n            result['message'] = f'Error creating client: {str(e)}'\n        \n        return result\n    \n    @staticmethod\n    def get_all_clients() -> List[Dict[str, Any]]:\n        \"\"\"Get all clients with access count\"\"\"\n        return Cliente.get_with_access_count()\n    \n    @staticmethod\n    def get_active_clients() -> List[Dict[str, Any]]:\n        \"\"\"Get only active clients\"\"\"\n        return Cliente.get_active()\n    \n    @staticmethod\n    def search_clients(term: str) -> List[Dict[str, Any]]:\n        \"\"\"Search clients (only active)\"\"\"\n        # Search only among active clients\n        all_results = Cliente.search(term)\n        return [client for client in all_results if client.get('estado') == 'activo']\n    \n    @staticmethod\n    def get_client_profile(client_id: int) -> Dict[str, Any]:\n        \"\"\"Get complete client profile with access history\"\"\"\n        client = Cliente.get_by_id(client_id)\n        if not client:\n            return {}\n        \n        accesses = Acceso.get_client_accesses(client_id)\n        active_accesses = [a for a in accesses if a['estado'] == 'activo']\n        \n        return {\n            'client': client,\n            'accesses': accesses,\n            'active_accesses': active_accesses,\n            'total_accesses': len(accesses),\n            'indicators_count': len(set(a['indicador_id'] for a in active_accesses))\n        }\n    \n    @staticmethod\n    def update_client(client_id: int, **kwargs) -> bool:\n        \"\"\"Update a client\"\"\"\n        return Cliente.update(client_id, **kwargs)\n    \n    @staticmethod\n    def deactivate_client(client_id: int) -> bool:\n        \"\"\"Deactivate a client (soft delete)\"\"\"\n        return Cliente.update(client_id, estado='inactivo')\n\nclass AccesoService:\n    \"\"\"Service for managing access permissions\"\"\"\n    \n    @staticmethod\n    def grant_access(username_tradingview: str, pub_id: str, days: int) -> Dict[str, Any]:\n        \"\"\"Grant access to a client for a specific indicator\"\"\"\n        result = {'success': False, 'message': '', 'access_id': None}\n        \n        try:\n            # Get or create client\n            client = Cliente.get_by_username(username_tradingview)\n            if not client:\n                # Try to create client automatically\n                client_result = ClienteService.create_client(username_tradingview)\n                if not client_result['success']:\n                    result['message'] = f\"Cliente no encontrado y no se pudo crear: {client_result['message']}\"\n                    return result\n                client = Cliente.get_by_id(client_result['client_id'])\n            \n            # Get indicator\n            indicator = Indicador.get_by_pub_id(pub_id)\n            if not indicator:\n                result['message'] = f\"Indicador no encontrado con PUB ID: {pub_id}\"\n                return result\n            \n            # Grant access\n            access_id = Acceso.grant_access(\n                cliente_id=client['id'],\n                indicador_id=indicator['id'],\n                days=days\n            )\n            \n            # Sync with TradingView API\n            try:\n                tv = tradingview()\n                tv_access = tv.get_access_details(username_tradingview, pub_id)\n                \n                if days == 30:\n                    tv.add_access(tv_access, 'M', 1)  # 1 month\n                else:\n                    tv.add_access(tv_access, 'd', days)\n                    \n            except Exception as tv_error:\n                result['message'] = f\"Acceso creado en DB pero error en TradingView: {str(tv_error)}\"\n                return result\n            \n            result['success'] = True\n            result['access_id'] = access_id\n            result['message'] = f\"Acceso otorgado por {days} días\"\n            \n        except Exception as e:\n            result['message'] = f\"Error granting access: {str(e)}\"\n        \n        return result\n    \n    @staticmethod\n    def revoke_access(username_tradingview: str, pub_id: str) -> Dict[str, Any]:\n        \"\"\"Revoke access for a client to specific indicator\"\"\"\n        result = {'success': False, 'message': ''}\n        \n        try:\n            # Get client and indicator\n            client = Cliente.get_by_username(username_tradingview)\n            indicator = Indicador.get_by_pub_id(pub_id)\n            \n            if not client:\n                result['message'] = \"Cliente no encontrado\"\n                return result\n                \n            if not indicator:\n                result['message'] = \"Indicador no encontrado\"\n                return result\n            \n            # Revoke in database\n            revoked = Acceso.revoke_access(client['id'], indicator['id'])\n            if not revoked:\n                result['message'] = \"No se encontró acceso activo para revocar\"\n                return result\n            \n            # Sync with TradingView API\n            try:\n                tv = tradingview()\n                tv_access = tv.get_access_details(username_tradingview, pub_id)\n                tv.remove_access(tv_access)\n            except Exception as tv_error:\n                result['message'] = f\"Acceso revocado en DB pero error en TradingView: {str(tv_error)}\"\n                return result\n            \n            result['success'] = True\n            result['message'] = \"Acceso revocado exitosamente\"\n            \n        except Exception as e:\n            result['message'] = f\"Error revoking access: {str(e)}\"\n        \n        return result\n    \n    @staticmethod\n    def check_access(username_tradingview: str, pub_id: str) -> Dict[str, Any]:\n        \"\"\"Check if a client has access to a specific indicator\"\"\"\n        result = {\n            'has_access': False,\n            'access_details': None,\n            'tradingview_status': None\n        }\n        \n        try:\n            # Check in database\n            client = Cliente.get_by_username(username_tradingview)\n            indicator = Indicador.get_by_pub_id(pub_id)\n            \n            if client and indicator:\n                access = Acceso.get_by_client_and_indicator(client['id'], indicator['id'])\n                if access:\n                    result['has_access'] = access['estado'] == 'activo'\n                    result['access_details'] = access\n            \n            # Check in TradingView\n            try:\n                tv = tradingview()\n                tv_access = tv.get_access_details(username_tradingview, pub_id)\n                result['tradingview_status'] = tv_access\n            except Exception:\n                pass  # TradingView check is optional\n                \n        except Exception:\n            pass  # Errors are handled by returning default result\n        \n        return result\n    \n    @staticmethod\n    def get_all_accesses() -> List[Dict[str, Any]]:\n        \"\"\"Get all active accesses\"\"\"\n        return Acceso.get_active_accesses()\n    \n    @staticmethod\n    def get_expiring_accesses(days: int = 7) -> List[Dict[str, Any]]:\n        \"\"\"Get accesses expiring in the next N days\"\"\"\n        return Acceso.get_expiring_soon(days)\n    \n    @staticmethod\n    def process_expired_accesses() -> int:\n        \"\"\"Process expired accesses and return count\"\"\"\n        return Acceso.mark_expired()\n\nclass DashboardService:\n    \"\"\"Service for dashboard statistics and overview\"\"\"\n    \n    @staticmethod\n    def get_dashboard_stats() -> Dict[str, Any]:\n        \"\"\"Get complete dashboard statistics\"\"\"\n        from .database import db\n        \n        stats = db.get_stats()\n        \n        # Get expiring soon\n        expiring_accesses = AccesoService.get_expiring_accesses(7)\n        \n        # Get recent activity (last 10 accesses created)\n        recent_accesses = Acceso.get_all(\"\", ())[:10]\n        \n        # Top indicators by usage\n        top_indicators_query = \"\"\"\n            SELECT i.nombre, i.pub_id, COUNT(a.id) as access_count\n            FROM indicadores i\n            LEFT JOIN accesos a ON i.id = a.indicador_id AND a.estado = 'activo'\n            WHERE i.estado = 'activo'\n            GROUP BY i.id, i.nombre, i.pub_id\n            ORDER BY access_count DESC\n            LIMIT 5\n        \"\"\"\n        top_indicators = db.execute_query(top_indicators_query)\n        \n        return {\n            'basic_stats': stats,\n            'expiring_accesses': expiring_accesses,\n            'recent_accesses': recent_accesses,\n            'top_indicators': top_indicators,\n            'alerts': {\n                'expiring_count': len(expiring_accesses),\n                'expired_count': stats.get('total_accesos', 0) - stats.get('accesos_activos', 0)\n            }\n        }","size_bytes":13456},"src/routes/__init__.py":{"content":"# Routes module","size_bytes":15},"src/routes/api_routes.py":{"content":"\"\"\"\nAPI Routes for PineScript Control Access\nNew management endpoints alongside existing legacy API\n\"\"\"\nfrom flask import Blueprint, request, jsonify\nfrom functools import wraps\nimport os\nfrom ..services import ClienteService, IndicadorService, AccesoService, DashboardService\n\n# Create blueprint for new API routes\napi_bp = Blueprint('api', __name__, url_prefix='/api/v1')\n\ndef require_admin_token(f):\n    \"\"\"Decorator for admin authentication - accepts both token headers and authenticated sessions\"\"\"\n    @wraps(f)\n    def decorated_function(*args, **kwargs):\n        from flask import session\n        \n        # Check for authenticated session first\n        if session.get('authenticated'):\n            return f(*args, **kwargs)\n        \n        # Fall back to token authentication\n        admin_token = request.headers.get('X-Admin-Token')\n        expected_token = os.getenv('ADMIN_TOKEN')\n        \n        if not expected_token:\n            return jsonify({'error': 'Server misconfigured - ADMIN_TOKEN not set'}), 500\n        \n        if not admin_token or admin_token != expected_token:\n            return jsonify({'error': 'Unauthorized - Authentication required'}), 401\n        \n        return f(*args, **kwargs)\n    return decorated_function\n\n# Dashboard endpoint\n@api_bp.route('/dashboard', methods=['GET'])\n@require_admin_token\ndef dashboard():\n    \"\"\"Get dashboard statistics\"\"\"\n    try:\n        stats = DashboardService.get_dashboard_stats()\n        return jsonify({\n            'success': True,\n            'data': stats\n        })\n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n\n# Client management endpoints\n@api_bp.route('/clients', methods=['GET'])\n@require_admin_token\ndef get_clients():\n    \"\"\"Get all clients\"\"\"\n    try:\n        search_term = request.args.get('search', '')\n        \n        if search_term:\n            clients = ClienteService.search_clients(search_term)\n        else:\n            clients = ClienteService.get_active_clients()\n        \n        return jsonify({\n            'success': True,\n            'data': clients\n        })\n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n\n@api_bp.route('/clients', methods=['POST'])\n@require_admin_token\ndef create_client():\n    \"\"\"Create a new client\"\"\"\n    try:\n        data = request.get_json()\n        \n        if not data or not data.get('username_tradingview'):\n            return jsonify({'error': 'username_tradingview is required'}), 400\n        \n        result = ClienteService.create_client(\n            username_tradingview=data['username_tradingview'],\n            email=data.get('email', ''),\n            nombre_completo=data.get('nombre_completo', '')\n        )\n        \n        if result['success']:\n            return jsonify(result), 201\n        else:\n            return jsonify(result), 400\n            \n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n\n@api_bp.route('/clients/<int:client_id>', methods=['GET'])\n@require_admin_token\ndef get_client_profile(client_id):\n    \"\"\"Get client profile with access history\"\"\"\n    try:\n        profile = ClienteService.get_client_profile(client_id)\n        \n        if not profile:\n            return jsonify({'error': 'Client not found'}), 404\n        \n        return jsonify({\n            'success': True,\n            'data': profile\n        })\n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n\n@api_bp.route('/clients/<int:client_id>', methods=['PUT'])\n@require_admin_token\ndef update_client(client_id):\n    \"\"\"Update a client\"\"\"\n    try:\n        data = request.get_json()\n        \n        if not data:\n            return jsonify({'error': 'No data provided'}), 400\n        \n        success = ClienteService.update_client(client_id, **data)\n        \n        if success:\n            return jsonify({'success': True, 'message': 'Client updated successfully'})\n        else:\n            return jsonify({'error': 'Client not found or update failed'}), 404\n            \n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n\n@api_bp.route('/clients/<int:client_id>', methods=['DELETE'])\n@require_admin_token\ndef deactivate_client(client_id):\n    \"\"\"Deactivate a client (soft delete)\"\"\"\n    try:\n        success = ClienteService.deactivate_client(client_id)\n        \n        if success:\n            return jsonify({'success': True, 'message': 'Client deactivated successfully'})\n        else:\n            return jsonify({'error': 'Client not found'}), 404\n            \n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n\n# Indicator management endpoints\n@api_bp.route('/indicators', methods=['GET'])\n@require_admin_token\ndef get_indicators():\n    \"\"\"Get all indicators\"\"\"\n    try:\n        search_term = request.args.get('search', '')\n        \n        if search_term:\n            indicators = IndicadorService.search_indicators(search_term)\n        else:\n            indicators = IndicadorService.get_all_indicators()\n        \n        return jsonify({\n            'success': True,\n            'data': indicators\n        })\n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n\n@api_bp.route('/indicators', methods=['POST'])\n@require_admin_token\ndef create_indicator():\n    \"\"\"Create a new indicator\"\"\"\n    try:\n        data = request.get_json()\n        \n        if not data or not data.get('nombre') or not data.get('pub_id'):\n            return jsonify({'error': 'nombre and pub_id are required'}), 400\n        \n        indicator_id = IndicadorService.create_indicator(\n            nombre=data['nombre'],\n            pub_id=data['pub_id'],\n            precio=float(data.get('precio', 0.0)),\n            version=data.get('version', '1.0'),\n            descripcion=data.get('descripcion', '')\n        )\n        \n        return jsonify({\n            'success': True,\n            'indicator_id': indicator_id,\n            'message': 'Indicator created successfully'\n        }), 201\n        \n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n\n@api_bp.route('/indicators/<int:indicator_id>', methods=['GET'])\n@require_admin_token\ndef get_indicator_stats(indicator_id):\n    \"\"\"Get indicator statistics\"\"\"\n    try:\n        stats = IndicadorService.get_indicator_stats(indicator_id)\n        \n        if not stats:\n            return jsonify({'error': 'Indicator not found'}), 404\n        \n        return jsonify({\n            'success': True,\n            'data': stats\n        })\n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n\n@api_bp.route('/indicators/<int:indicator_id>', methods=['PUT'])\n@require_admin_token\ndef update_indicator(indicator_id):\n    \"\"\"Update an indicator\"\"\"\n    try:\n        data = request.get_json()\n        \n        if not data:\n            return jsonify({'error': 'No data provided'}), 400\n        \n        success = IndicadorService.update_indicator(indicator_id, **data)\n        \n        if success:\n            return jsonify({'success': True, 'message': 'Indicator updated successfully'})\n        else:\n            return jsonify({'error': 'Indicator not found or update failed'}), 404\n            \n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n\n@api_bp.route('/indicators/<int:indicator_id>', methods=['DELETE'])\n@require_admin_token\ndef delete_indicator(indicator_id):\n    \"\"\"Delete an indicator (soft delete)\"\"\"\n    try:\n        success = IndicadorService.delete_indicator(indicator_id)\n        \n        if success:\n            return jsonify({'success': True, 'message': 'Indicator deleted successfully'})\n        else:\n            return jsonify({'error': 'Indicator not found'}), 404\n            \n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n\n# Access management endpoints\n@api_bp.route('/access', methods=['GET'])\n@require_admin_token\ndef get_accesses():\n    \"\"\"Get all accesses\"\"\"\n    try:\n        filter_type = request.args.get('filter', 'all')  # all, active, expiring\n        \n        if filter_type == 'expiring':\n            days = int(request.args.get('days', 7))\n            accesses = AccesoService.get_expiring_accesses(days)\n        elif filter_type == 'active':\n            accesses = AccesoService.get_all_accesses()\n        else:\n            accesses = AccesoService.get_all_accesses()  # Default to active for now\n        \n        return jsonify({\n            'success': True,\n            'data': accesses\n        })\n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n\n@api_bp.route('/access', methods=['POST'])\n@require_admin_token\ndef grant_access():\n    \"\"\"Grant access to a client\"\"\"\n    try:\n        data = request.get_json()\n        \n        required_fields = ['client_id', 'indicator_id', 'duracion_dias']\n        if not data or not all(field in data for field in required_fields):\n            return jsonify({\n                'error': f'Required fields: {\", \".join(required_fields)}'\n            }), 400\n        \n        # Get client and indicator details for AccesoService\n        from ..models import Cliente, Indicador\n        client = Cliente.get_by_id(data['client_id'])\n        indicator = Indicador.get_by_id(data['indicator_id'])\n        \n        if not client or not indicator:\n            return jsonify({'error': 'Client or indicator not found'}), 400\n        \n        result = AccesoService.grant_access(\n            username_tradingview=client['username_tradingview'],\n            pub_id=indicator['pub_id'],\n            days=int(data['duracion_dias'])\n        )\n        \n        if result['success']:\n            return jsonify(result), 201\n        else:\n            return jsonify(result), 400\n            \n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n\n@api_bp.route('/access/<int:client_id>/<int:indicator_id>', methods=['DELETE'])\n@require_admin_token\ndef revoke_access(client_id, indicator_id):\n    \"\"\"Revoke access from a client\"\"\"\n    try:\n        # Get client and indicator details for AccesoService\n        from ..models import Cliente, Indicador\n        client = Cliente.get_by_id(client_id)\n        indicator = Indicador.get_by_id(indicator_id)\n        \n        if not client or not indicator:\n            return jsonify({'error': 'Client or indicator not found'}), 400\n        \n        result = AccesoService.revoke_access(\n            username_tradingview=client['username_tradingview'],\n            pub_id=indicator['pub_id']\n        )\n        \n        if result['success']:\n            return jsonify(result)\n        else:\n            return jsonify(result), 400\n            \n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n\n# Maintenance endpoint\n@api_bp.route('/maintenance/expired', methods=['POST'])\n@require_admin_token\ndef process_expired_accesses():\n    \"\"\"Process expired accesses\"\"\"\n    try:\n        # This could clean up expired accesses or send notifications\n        # For now, just return success\n        return jsonify({\n            'success': True,\n            'message': 'Expired accesses processed successfully'\n        })\n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n\n@api_bp.route('/access/check', methods=['POST'])\n@require_admin_token\ndef check_access():\n    \"\"\"Check access status for a client\"\"\"\n    try:\n        data = request.get_json()\n        \n        required_fields = ['username_tradingview', 'pub_id']\n        if not data or not all(field in data for field in required_fields):\n            return jsonify({\n                'error': f'Required fields: {\", \".join(required_fields)}'\n            }), 400\n        \n        result = AccesoService.check_access(\n            username_tradingview=data['username_tradingview'],\n            pub_id=data['pub_id']\n        )\n        \n        return jsonify({\n            'success': True,\n            'data': result\n        })\n        \n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n\n# Maintenance endpoints\n@api_bp.route('/maintenance/expired', methods=['POST'])\n@require_admin_token\ndef process_expired():\n    \"\"\"Process expired accesses\"\"\"\n    try:\n        count = AccesoService.process_expired_accesses()\n        \n        return jsonify({\n            'success': True,\n            'message': f'Processed {count} expired accesses'\n        })\n        \n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n\n# Token validation endpoints\n@api_bp.route(\"/validate-token\", methods=[\"POST\", \"GET\"])\ndef validate_token():\n    \"\"\"Validate admin token and provide clear feedback\"\"\"\n    import os\n    \n    # Get token from header or JSON body\n    admin_token = request.headers.get(\"X-Admin-Token\")\n    if not admin_token and request.method == \"POST\":\n        data = request.get_json() or {}\n        admin_token = data.get(\"token\")\n    \n    expected_token = os.getenv(\"ADMIN_TOKEN\")\n    \n    if not expected_token:\n        return jsonify({\n            \"valid\": False,\n            \"error\": \"Server misconfigured - ADMIN_TOKEN not set\",\n            \"message\": \"Contacta al administrador del sistema\"\n        }), 500\n    \n    if not admin_token:\n        return jsonify({\n            \"valid\": False,\n            \"error\": \"No token provided\",\n            \"message\": \"Incluye el token en el header X-Admin-Token o en el body como \\\"token\\\"\"\n        }), 400\n    \n    if admin_token == expected_token:\n        return jsonify({\n            \"valid\": True,\n            \"message\": \"✅ Token válido - Acceso autorizado\",\n            \"permissions\": [\"dashboard\", \"clients\", \"indicators\", \"access_management\"]\n        })\n    else:\n        return jsonify({\n            \"valid\": False,\n            \"error\": \"Invalid token\",\n            \"message\": \"❌ Token inválido - Acceso denegado\",\n            \"hint\": f\"Token recibido: {admin_token[:12]}... (truncado por seguridad)\"\n        }), 401\n\n@api_bp.route(\"/get-token\", methods=[\"GET\"])\ndef get_current_token():\n    \"\"\"Get current admin token (development only)\"\"\"\n    import os\n    if os.getenv(\"ENV\") == \"production\":\n        return jsonify({\"error\": \"Token access disabled in production\"}), 403\n    \n    token = os.getenv(\"ADMIN_TOKEN\")\n    if token:\n        return jsonify({\n            \"token\": token,\n            \"message\": \"Use this token in X-Admin-Token header for admin operations\"\n        })\n    else:\n        return jsonify({\"error\": \"No token found\"}), 404\n\n","size_bytes":14404}},"version":1}